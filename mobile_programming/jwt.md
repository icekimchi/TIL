# JWT(Json Web Token) 인증방식

## Cookie
> 클라이언트가 웹 사이트에 접속하면 남는 작은 기록 파일   
> 접속자 장치를 인식하거나 일부 데이터를 저장하는 역할   
> 서버가 클라이언트에 정보를 전달할 떄, 전달하고자 하는 정보를 응답 헤더(Cookie)에 저장하여 전달한다.   
> Key Value 형식의 문자열 형태로 저장한다.   
    
 최초로 ID, pw로 로그인을 하면, 이후에는 로그인이 된 상태에서 요청을 날릴 수가 있다. 만약 ,쿠키가 없었다면 매번 요청을 할 때마다 쿠키로 ID, PW를 동시에 날려야하는 번거로움이 생겼었던 것이다.

>POST http://localhost:8080/api/login   
> HTTP/1.1 200 
Set-Cookie: id=jinyoungchoi95; Max-Age=10000; Expires=Mon, 15-Nov-2021 16:29:57 GMT   
> Set-Cookie: pw=jycpassword12; Max-Age=10000; Expires=Mon, 15-Nov-2021 16:29:57 GMT   

### Cookie의 단점
> 1. id, pw에 대한 민감 정보까지 다 노출이 되어 보안이 좋지 않다.
> 2. 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에, 브라우저 간의 공유가 불가능
> 3. 쿠키의 사이즈 제한 때문에, 원하는 만큼의 충분한 데이터를 담을 수 없다.
> 4. 서버는 매번 id, pw를 받아서 인증을 해야하는 번거로움
> 5. 조작된 데이터가 넘어오는 경우, 방지할 수 없다.   
   

이를 보완하기 위해 나온 것이 Session이다.
***

## Cookie & Session
여기서 id pw를 주고 받지 말고 인증 정보자체를 특정 세션 저장소에 저장하고, 이 값을 쿠키에 담아 클라이언트가 쿠키를 요청할 때마다 세션 저장소에 있는 정보랑 동일한지로 로그인을 확인하자가 주요 핵심이다.

![Cookie$Session](./images/image.png)


> 1. 클라이언트가 id pw로 서버에 로그인 요청을 한다.
> 2. id pw로 인증 후 사용자를 식별할 특정 유니크한 세션 ID를 만들어 마치 자물쇠처럼 서버의 세션 저장소에 저장한다.
> 3. 세션 ID를 특정한 형태(쿠키 or json)로 클라이언트에 다시 반환한다.
> 4. 이후 사용자 인증이 필요한 정보를 요청할 때마다 이 세션 ID를 쿠키에 담아 서버에 함께 전달한다.
> 5. 인증이 필요한 api일 때, 서버는 세션 ID가 세션 저장소에 있는 지 확인한다.
>6. 있다면 인증 완료 후 api 처리, 없다면 401 에러를 반환한다.

### Session을 사용했을 때의 단점
> * 세션 저장소의 문제가 발생하면 인증 체계가 무너져 이전에 다른 인증된 유저 또한 인증이 불가해진다.
> * stateful하기 때문에 http의 장점을 발휘하지 못하고 scale out에 걸림돌이 생긴다. -> 이는 http에서 다루는 내용
> *세션 저장소가 필수적으로 존재하기 때문에 이를 사용하기위한 비용이 든다.
> * 세션 ID가 탈취되었을 경우 대처는 가능하지만 클라이언트인척 위장하는 보안의 약점이 있을 수 있다.
> * 사용자가 많아질수록 메모리를 많이 차지하게 된다.
> * "매번" 요청 시 DB에서 세션 저장소를 조회해야하는 단점이 있다.

***
## JWT의 등장
> 인증에 필요한 정보들을 Token에 담아 암호화시켜 사용하는 토큰이다.   
> 기본적인 인증을 진행하는 구조는 Cookie때와 크게 다르지는 않지만, 강조되는 점은 JWT는 서명된 토큰이라는 점이다. <br/>공개/개인 키를 쌍으로 사용하여 토큰에 서명할 경우 서명된 토큰은 개인 키를 보유한 서버가 이 서명된 토큰이 정상적인 토큰인지 인증할 수 있다는 이야기이죠.

<br/>

### JWT의 구조
![JWT의 구조](./images/image-2.png)
> 1. header
> 2. payload
> 3. Signature


## 1. header
보통 토큰의 타입이나, 서명 생성에 어떤 알고리즘이 사용되었는지 저장한다.

```json
{
    "typ": "JWT",
    "alg": "HS512"
}
   ```

위 코드는 토큰의 타입이 JWT이고, 개인키로 HS512 알고리즘이 적용되어 암호화가 되어있다고 확인할 수 있다.😀

## 2. Paylaod
Claim이라는 사용자에 대한, 혹은 토큰에 대한 property를 key-value 형태로 저장한다. 토큰에서 사용할 정보의 조각인 셈이다. 

Claim의 표준 스텍
> 1. `iss` (issue) : 토큰 발급자
> 2. `sub` (subject) : 토큰 제목 (사용자에 대한 식별값)
> 3. `aud` (Audience) : 토큰 대상자
> 4. `exp` (Expiration Time) : 토큰 만료 시간
> 5. `nbf` (Not Before) : 토큰 활성 날짜 (이전에는 사용 불가)
> 6. `iat` (Issued AT) : 토큰 발급 시간
> 7. `jti` (JWT id) : JWT 토큰 식별자 (issue가 여러 명일 때 구분 위함)

가장 중요한 것은 **payload에 민감한 정보를 담지 않는 것**이다. header와 payload는 json 디코딩이 되어 있을 뿐 암호화가 걸려 있는 것은 아니기 때문에 누구나 jwt로 디코딩을 할 수 있다.

![Decoing 사진](/mobile_programming/images/decoing_jwt.png)

* jwt.io에서 서버에서 생성한 JWT를 넣기만해도 볼 수 있는 화면이다. JWT에서 header와 payload는 특별한 암호화없이 흔히 사용할 수 있는 base64 인코딩을 사용하기 때문에 서버가 아니더라도 그 값들을 확인할 수 있습니다.

* 그래서 JWT는 단순히 "식별을 하기위한" 정보만을 담아두어야하는 것입니다.

# 3. Signature
![Signature](/mobile_programming/images/Signature.png)

  
>header를 디코딩한 값, payload를 디코딩한 값을 위처럼 합치고 이를 your-256-bit-secret 즉, 서버가 가지고 있는 개인키를 가지고 암호화되어있는 상태이다.
>따라서 signature는 서버에 있는 개인키로만 암호화를 풀 수 있으므로 다른 클라이언트는 임의로 Signature를 복호화할 수 없습니다.

1. JWT 토큰을 클라이언트가 서버로 요청과 동시에 전달한다.
2. 서버가 가지고 있는 개인키를 가지고 Signature를 복호화 한 다음 base64UrlEncode(header)가 JWT의 heaer값과 일치한지, base64UrlEncode(payload) 와 일치한지 확인하여 일치한다면 인증을 허용한다.
   
`장점`
  > 1. 이미 토큰 자체가 인증된 정보이기 때문에 `세션 저장소`와 같은 별도의 인증 저장소가 "필수적"으로 필요하지 않다.
  > 2. 세션과는 다르게 클라이언트의 상태를 서버가 저장해두지 않아도 된다.
  > 3. signature를 공통키 개인키 암호화를 통해 막아두었기 때문에 데이터에 대한 보완성이 늘어난다.
  > 4. 다른 서비스에 이용할 수 있는 공통적인 스펙으로써 사용할 수 있다.

`요약`
> **stateful**해야하는 세션의 단점을 보완하기 위해 만들어진 JWT는 별도의 세션 저장소를 강제하지 않기 때문에 **stateless**하여 **확장성**이 뛰어나고, signature를 통한 **보안성**까지 갖추고있다.
